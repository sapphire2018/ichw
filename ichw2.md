# 停机问题(Halting Problem)  
* 图灵为什么要证明停机问题？  
图灵当年想要证明希尔伯特的可判定性问题，也就是说，是否存在一种通用的机械过程，能够判定任何数学命题的真假。于是图灵就设计了一种假想的机器，也就是图灵机。他首先证明，图灵机就覆盖了所有的“机械过程”，如果存在一个问题，图灵机判定不了，那么就说明，不存在这种“通用的”过程，这样就证明了原问题。  
* 证明方法  
图灵设计了一个问题 图灵机判定不了  
设计一个程序H，当输入程序P和输入I时，程序H能判断是否停机  
在设计一个程序K，当H输出停机时，K不停机，当输出不停机时，K停机  
在H中输入K可以发现出现矛盾：即若H判断K停机，则K不停机；若H判断K不停机，则K停机  
证明完毕。  
* 数学原理——哥德尔不完全性定理  
任何一个形式系统，只要包括了简单的初等数论描述，而且是自洽的，它必定包含某些系统内所允许的方法既不能证明真也不能证伪的命题。
***

# 科普：补码原理  
* 二进制简介   
计算机使用二进制，因为大部分物理器件有两种稳定状态，使用二进制较稳定且易于实现，还有可靠性高、运算规则简单能提升计算机速度等优点。  
* 二进制与十进制转换
正整数转成二进制。要点一定一定要记住哈：除二取余，然后倒序排列，高位补零。   
正整数转化二进制示例：6/2=3······0  
                    3/2=1······1  因此6转化为二进制是110  
* 原码  
数会有正负 原码表示正负是用最高位的0和1来表示，如果最高位为0，则为正数；如果最高位为1，则为负数。  
* 反码  
用正整数相反的来代表该正整数的负数  
如：设定5bit     则6为00110，-6为11001  
然而此时有两个0（即00000和11111）  
* 补码  
为了不出现两个0  
可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（符号位除外）各位取反，并在末项加1得到的。  
反码需循环进位  
***

# 浮点数格式的二进制表示     IEEE 754  
16bit 8小数位
+0    0011111100000000  
-0    1011111100000000  
+1    0000000100000000  
-1    1000000100000000  
最大非规范浮点数  0000000000000001  
最小非规范浮点数  0000000011111111  
最小规范浮点数    0000000100000000  
最大规范浮点数    1111111011111111  
NaN  exp全为1   尾数非全0    如1111111100100101  
+∞  0111111100000000  
-∞  1111111100000000



                 
